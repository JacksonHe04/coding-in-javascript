/**
 * 寻找给定字符串中的最长回文子串。
 * 
 * 该函数通过中心扩展算法来寻找回文串。对于每个字符，它会尝试以该字符为中心的奇数长度回文串
 * 和以该字符与下一个字符之间为中心的偶数长度回文串。通过比较所有找到的回文串的长度，最终确定最长的回文子串。
 * 
 * @param {string} s 输入的字符串。
 * @return {string} 返回找到的最长回文子串。
 */
var longestPalindrome = function (s) {
    // 如果字符串长度小于2，直接返回原字符串，因为单个字符必然是回文串
    if (s.length < 2) {
        return s
    }
    // 用于存储最长回文子串
    let res = ''
    
    // 遍历字符串的每个字符，以其为中心向两边扩展
    for (let i = 0; i < s.length; i++) {
        // 处理奇数长度的回文串，如 "aba"，以单个字符为中心
        helper(i, i)
        // 处理偶数长度的回文串，如 "abba"，以两个字符之间的空隙为中心
        helper(i, i + 1)
    }

    // 辅助函数：从中心向两边扩展寻找回文串
    function helper(m, n) {
        // 当左右指针在合法范围内且对应字符相等时，继续向两边扩展
        while (m >= 0 && n < s.length && s[m] == s[n]) {
            m--
            n++
        }
        // 循环结束时，m和n指向的是不满足回文条件的位置
        // 实际的回文串在[m+1, n-1]范围内
        // 如果当前回文串长度大于已记录的最长回文串，则更新结果
        if (n - m - 1 > res.length) {
            // 截取回文串，范围是[m+1, n)
            res = s.slice(m + 1, n)
        }
    }
    
    // 返回找到的最长回文子串
    return res
};